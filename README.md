# 类笔记  

## Class 继承  

**利用super( )来调用父类的构造函数。  
1.super( )必须在子类this之前调用。  
2.类里共有的属性和方法一定要加this。  
3.constructer里面的this指向实例对象，方法里的this指向这个方法的调用者。**  

## new 执行过程

**1.在内存中创造一个空对象。  
2.让this指向这个空对象。  
3.执行构造函数里的代码，给这个新对象添加属性和方法。  
4.返回这个新对象（所以构造函数里不需要添加return。**  

## 构造函数  

**1.实例成员只能通过实例化的对象来访问。  
2.静态成员只能通过构造函数来实现。  
3.构造函数方法很好用，但是存在浪费内存的的问题（每一次实例化对象都会开辟不同的内存空间来存放数据，即使类方法一模一样）。**  

## 构造函数原型 prototype(原型对象)

**1.构造函数通过原型分配的函数是所有对象所共享的。  
 2.每一个构造函数都有一个prototype属性，指向另一个对象。这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。  
 ***（我们可以把那些不变的方法，直接定义到prototype对象内，这样所有的实例就可以共享这些方法）。  
 原型的作用：共享方法。***  
 3.一般情况下，我们的公共属性定义到构造方法里面，公共的方法放到原型对象身上。  
 4.如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用constructor指回原来的构造函数。  
 5.原型对象里也有__proto__原型，__proto__原型指向的是object.prototype,而object.prototype里的proto原型指向为null。**  

 **原型对象中this的指向问题：**  

* 在构造函数中，里面的this指向的是对象实例。
* 原型对象中的this指向的是实例对象。（一般情况指向的是函数的调用者）。两者都指向实例的对象。

## 对象原型__proto

**对象都会有一个属性__proto__:**

* 指向构造函数的prototype原型对象，
* 之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有_proto__原型的存在,
* 对象的__proto__属性与构造函数（类）的prototype是等价的.
* __proto__属性是非标准属性，实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype。
* constructor主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。

**方法的查找规则：**

* 先看对象身上是否有该方法，有则直接调用，如果没有则通过__proto__去构造函数原型对象prototype上查找该方法。

##[异步编程与promise](./promise.md)


